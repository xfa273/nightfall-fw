#!/usr/bin/env python3

import argparse
import glob
import os
import struct
import sys
import time

import termios


ACK = 0x79
NACK = 0x1F

CMD_GETID = 0x02
CMD_GOMEM = 0x21
CMD_WRITEMEM = 0x31
CMD_EXT_ERASE = 0x44


def xor_checksum(bs: bytes) -> int:
    x = 0
    for b in bs:
        x ^= b
    return x & 0xFF


def open_uart_8e1(port: str, baud: int) -> int:
    fd = os.open(port, os.O_RDWR | os.O_NOCTTY | os.O_NONBLOCK)

    attrs = termios.tcgetattr(fd)
    attrs[0] = 0
    attrs[1] = 0
    attrs[3] = 0

    cflag = attrs[2]
    cflag |= (termios.CLOCAL | termios.CREAD)
    cflag &= ~termios.CSIZE
    cflag |= termios.CS8
    cflag |= termios.PARENB
    cflag &= ~termios.PARODD
    cflag &= ~termios.CSTOPB
    attrs[2] = cflag

    if baud != 115200:
        raise ValueError("Only 115200 is supported in this script")

    attrs[4] = termios.B115200
    attrs[5] = termios.B115200

    attrs[6][termios.VMIN] = 0
    attrs[6][termios.VTIME] = 3

    termios.tcsetattr(fd, termios.TCSANOW, attrs)
    try:
        termios.tcflush(fd, termios.TCIOFLUSH)
    except Exception:
        pass

    return fd


def read_exact(fd: int, n: int, timeout_s: float) -> bytes:
    out = b""
    t0 = time.time()
    while len(out) < n and (time.time() - t0) < timeout_s:
        try:
            chunk = os.read(fd, n - len(out))
        except BlockingIOError:
            chunk = b""
        if chunk:
            out += chunk
        else:
            time.sleep(0.01)
    return out


def read_byte(fd: int, timeout_s: float):
    d = read_exact(fd, 1, timeout_s)
    return d[0] if d else None


def send(fd: int, data: bytes) -> None:
    os.write(fd, data)


def send_cmd(fd: int, cmd: int) -> None:
    send(fd, bytes([cmd, cmd ^ 0xFF]))


def expect_ack(fd: int, where: str, timeout_s: float) -> None:
    b = read_byte(fd, timeout_s)
    if b is None:
        raise RuntimeError(f"{where}: timeout")
    if b != ACK:
        raise RuntimeError(f"{where}: expected ACK(0x79) got 0x{b:02X}")


def render_bar(prefix: str, progress: float, suffix: str = "", width: int = 32) -> None:
    if progress < 0:
        progress = 0.0
    if progress > 1:
        progress = 1.0
    filled = int(round(width * progress))
    bar = "=" * filled + "-" * (width - filled)
    sys.stdout.write(f"\r{prefix} [{bar}] {progress*100:6.2f}%{suffix}")
    sys.stdout.flush()


def get_id(fd: int) -> bytes:
    send_cmd(fd, CMD_GETID)
    expect_ack(fd, "GETID ack1", 2.0)
    n = read_byte(fd, 2.0)
    if n is None:
        raise RuntimeError("GETID: no length")
    data = read_exact(fd, n + 1, 2.0)
    expect_ack(fd, "GETID ack2", 2.0)
    return data


def connect_or_reuse(fd: int, total_wait_s: float) -> bytes:
    deadline = time.time() + total_wait_s
    attempt = 0
    while time.time() < deadline:
        attempt += 1
        send(fd, b"\x7F")
        b = read_byte(fd, 0.6)
        if b == ACK:
            return get_id(fd)
        if b == NACK:
            try:
                did = get_id(fd)
                return did
            except Exception:
                pass
        time.sleep(0.2)

    raise RuntimeError("connect/reuse failed")


def extended_erase_all(fd: int) -> None:
    send_cmd(fd, CMD_EXT_ERASE)
    expect_ack(fd, "EXT_ERASE ack1", 2.0)
    payload = bytes([0xFF, 0xFF])
    send(fd, payload + bytes([xor_checksum(payload)]))
    print("Erasing...")
    expect_ack(fd, "EXT_ERASE ack2", 40.0)


def write_memory(fd: int, addr: int, data: bytes) -> None:
    if not (1 <= len(data) <= 256):
        raise ValueError("chunk size must be 1..256")

    send_cmd(fd, CMD_WRITEMEM)
    expect_ack(fd, "WRITEMEM ack1", 2.0)

    ab = struct.pack(">I", addr)
    send(fd, ab + bytes([xor_checksum(ab)]))
    expect_ack(fd, "WRITEMEM ack2", 2.0)

    ln = (len(data) - 1) & 0xFF
    payload = bytes([ln]) + data
    send(fd, payload + bytes([xor_checksum(payload)]))
    expect_ack(fd, "WRITEMEM ack3", 4.0)


def go(fd: int, addr: int) -> None:
    send_cmd(fd, CMD_GOMEM)
    expect_ack(fd, "GO ack1", 2.0)
    ab = struct.pack(">I", addr)
    send(fd, ab + bytes([xor_checksum(ab)]))
    expect_ack(fd, "GO ack2", 2.0)


def detect_port() -> str:
    candidates = []
    for pat in (
        "/dev/cu.usbserial-*",
        "/dev/cu.usbmodem-*",
        "/dev/cu.SLAB_USBtoUART*",
        "/dev/cu.wchusbserial*",
    ):
        candidates.extend(glob.glob(pat))
    candidates = sorted(set(candidates))
    if not candidates:
        raise RuntimeError("UARTポートが見つかりません: /dev/cu.usbserial-* など")
    if len(candidates) == 1:
        return candidates[0]
    raise RuntimeError("UARTポート候補が複数あります。--port で指定してください: " + ", ".join(candidates))


def default_bin_path() -> str:
    p = "build/Debug/HM_Nightfall-mini_v1.1.bin"
    if os.path.isfile(p):
        return p
    hits = []
    for pat in ("build/*/HM_Nightfall-mini_v1.1.bin", "build/*/*.bin"):
        hits.extend(glob.glob(pat))
    hits = [h for h in hits if os.path.isfile(h)]
    if not hits:
        raise RuntimeError(".bin が見つかりません。先にビルドしてください")
    return sorted(hits)[0]


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--port", default=None)
    ap.add_argument("--baud", type=int, default=115200)
    ap.add_argument("--bin", dest="bin_path", default=None)
    ap.add_argument("--no-erase", action="store_true")
    ap.add_argument("--no-go", action="store_true")
    ap.add_argument("--base", default="0x08000000")
    ap.add_argument("--timeout", type=float, default=30.0)
    args = ap.parse_args()

    port = args.port or detect_port()
    bin_path = args.bin_path or default_bin_path()
    base = int(args.base, 0)

    with open(bin_path, "rb") as f:
        blob = f.read()

    print(f"PORT: {port}")
    print(f"BIN : {bin_path} ({len(blob)} bytes)")

    fd = open_uart_8e1(port, args.baud)
    try:
        did = connect_or_reuse(fd, args.timeout)
        if len(did) >= 2:
            chip_id = (did[-2] << 8) | did[-1]
            print(f"Device ID: 0x{chip_id:04X}")

        if not args.no_erase:
            extended_erase_all(fd)

        chunk = 256
        t0 = time.time()
        for off in range(0, len(blob), chunk):
            part = blob[off : off + chunk]
            write_memory(fd, base + off, part)
            written = off + len(part)
            render_bar("Write", written / len(blob), suffix=f" ({written}/{len(blob)} bytes)")
        sys.stdout.write("\n")
        print(f"write done in {time.time() - t0:.1f}s")

        if not args.no_go:
            go(fd, base)

        print("SUCCESS")
        return 0
    finally:
        os.close(fd)


if __name__ == "__main__":
    raise SystemExit(main())
