#!/usr/bin/env python3

import argparse
import glob
import os
import struct
import sys
import time

import termios


ACK = 0x79
NACK = 0x1F

CMD_GETID = 0x02
CMD_GOMEM = 0x21
CMD_WRITEMEM = 0x31
CMD_EXT_ERASE = 0x44


# STM32F405 internal Flash sector map (Bank1)
# Sector 0..3: 16KB, Sector 4: 64KB, Sector 5..11: 128KB
_F405_SECTORS = [
    (0, 0x08000000, 16 * 1024),
    (1, 0x08004000, 16 * 1024),
    (2, 0x08008000, 16 * 1024),
    (3, 0x0800C000, 16 * 1024),
    (4, 0x08010000, 64 * 1024),
    (5, 0x08020000, 128 * 1024),
    (6, 0x08040000, 128 * 1024),
    (7, 0x08060000, 128 * 1024),
    (8, 0x08080000, 128 * 1024),
    (9, 0x080A0000, 128 * 1024),
    (10, 0x080C0000, 128 * 1024),
    (11, 0x080E0000, 128 * 1024),
]

# Persistent data sectors (do NOT erase during normal firmware update)
# - Sector 9 : distance_params (0x080A0000)
# - Sector 10: flash_params (0x080C0000)
# - Sector 11: maze EEPROM emulation (0x080E0000)
_PROTECTED_SECTORS_DEFAULT = {9, 10, 11}


def xor_checksum(bs: bytes) -> int:
    x = 0
    for b in bs:
        x ^= b
    return x & 0xFF


def open_uart_8e1(port: str, baud: int) -> int:
    fd = os.open(port, os.O_RDWR | os.O_NOCTTY | os.O_NONBLOCK)

    attrs = termios.tcgetattr(fd)
    attrs[0] = 0
    attrs[1] = 0
    attrs[3] = 0

    cflag = attrs[2]
    cflag |= (termios.CLOCAL | termios.CREAD)
    cflag &= ~termios.CSIZE
    cflag |= termios.CS8
    cflag |= termios.PARENB
    cflag &= ~termios.PARODD
    cflag &= ~termios.CSTOPB
    attrs[2] = cflag

    if baud != 115200:
        raise ValueError("Only 115200 is supported in this script")

    attrs[4] = termios.B115200
    attrs[5] = termios.B115200

    attrs[6][termios.VMIN] = 0
    attrs[6][termios.VTIME] = 3

    termios.tcsetattr(fd, termios.TCSANOW, attrs)
    try:
        termios.tcflush(fd, termios.TCIOFLUSH)
    except Exception:
        pass

    return fd


def read_exact(fd: int, n: int, timeout_s: float) -> bytes:
    out = b""
    t0 = time.time()
    while len(out) < n and (time.time() - t0) < timeout_s:
        try:
            chunk = os.read(fd, n - len(out))
        except BlockingIOError:
            chunk = b""
        if chunk:
            out += chunk
        else:
            time.sleep(0.01)
    return out


def read_byte(fd: int, timeout_s: float):
    d = read_exact(fd, 1, timeout_s)
    return d[0] if d else None


def send(fd: int, data: bytes) -> None:
    os.write(fd, data)


def send_cmd(fd: int, cmd: int) -> None:
    send(fd, bytes([cmd, cmd ^ 0xFF]))


def expect_ack(fd: int, where: str, timeout_s: float) -> None:
    b = read_byte(fd, timeout_s)
    if b is None:
        raise RuntimeError(f"{where}: timeout")
    if b != ACK:
        raise RuntimeError(f"{where}: expected ACK(0x79) got 0x{b:02X}")


def render_bar(prefix: str, progress: float, suffix: str = "", width: int = 32) -> None:
    if progress < 0:
        progress = 0.0
    if progress > 1:
        progress = 1.0
    filled = int(round(width * progress))
    bar = "=" * filled + "-" * (width - filled)
    sys.stdout.write(f"\r{prefix} [{bar}] {progress*100:6.2f}%{suffix}")
    sys.stdout.flush()


def get_id(fd: int) -> bytes:
    send_cmd(fd, CMD_GETID)
    expect_ack(fd, "GETID ack1", 2.0)
    n = read_byte(fd, 2.0)
    if n is None:
        raise RuntimeError("GETID: no length")
    data = read_exact(fd, n + 1, 2.0)
    expect_ack(fd, "GETID ack2", 2.0)
    return data


def connect_or_reuse(fd: int, total_wait_s: float) -> bytes:
    deadline = time.time() + total_wait_s
    attempt = 0
    while time.time() < deadline:
        attempt += 1
        send(fd, b"\x7F")
        b = read_byte(fd, 0.6)
        if b == ACK:
            return get_id(fd)
        if b == NACK:
            try:
                did = get_id(fd)
                return did
            except Exception:
                pass
        time.sleep(0.2)

    raise RuntimeError("connect/reuse failed")


def extended_erase_all(fd: int) -> None:
    send_cmd(fd, CMD_EXT_ERASE)
    expect_ack(fd, "EXT_ERASE ack1", 2.0)
    payload = bytes([0xFF, 0xFF])
    send(fd, payload + bytes([xor_checksum(payload)]))
    print("Erasing...")
    expect_ack(fd, "EXT_ERASE ack2", 40.0)


def _f405_sector_for_addr(addr: int) -> int:
    for sid, start, size in _F405_SECTORS:
        if start <= addr < (start + size):
            return sid
    raise RuntimeError(f"address out of F405 flash range: 0x{addr:08X}")


def _f405_sectors_cover_range(start_addr: int, size_bytes: int) -> list[int]:
    if size_bytes <= 0:
        return []
    end_addr = start_addr + size_bytes - 1
    s0 = _f405_sector_for_addr(start_addr)
    s1 = _f405_sector_for_addr(end_addr)
    return list(range(s0, s1 + 1))


def extended_erase_sectors(fd: int, sectors: list[int]) -> None:
    if not sectors:
        return
    if len(sectors) > 0x10000:
        raise ValueError("too many sectors")

    send_cmd(fd, CMD_EXT_ERASE)
    expect_ack(fd, "EXT_ERASE ack1", 2.0)

    # AN3155: payload = N(16-bit) + page numbers (16-bit each) + checksum
    # N = number_of_pages - 1
    n = len(sectors) - 1
    payload = struct.pack(">H", n)
    for s in sectors:
        payload += struct.pack(">H", s & 0xFFFF)

    send(fd, payload + bytes([xor_checksum(payload)]))
    print(f"Erasing sectors: {sectors}")
    expect_ack(fd, "EXT_ERASE ack2", 40.0)


def write_memory(fd: int, addr: int, data: bytes) -> None:
    if not (1 <= len(data) <= 256):
        raise ValueError("chunk size must be 1..256")

    send_cmd(fd, CMD_WRITEMEM)
    expect_ack(fd, "WRITEMEM ack1", 2.0)

    ab = struct.pack(">I", addr)
    send(fd, ab + bytes([xor_checksum(ab)]))
    expect_ack(fd, "WRITEMEM ack2", 2.0)

    ln = (len(data) - 1) & 0xFF
    payload = bytes([ln]) + data
    send(fd, payload + bytes([xor_checksum(payload)]))
    expect_ack(fd, "WRITEMEM ack3", 4.0)


def go(fd: int, addr: int) -> None:
    send_cmd(fd, CMD_GOMEM)
    expect_ack(fd, "GO ack1", 2.0)
    ab = struct.pack(">I", addr)
    send(fd, ab + bytes([xor_checksum(ab)]))
    expect_ack(fd, "GO ack2", 2.0)


def detect_port() -> str:
    candidates = []
    for pat in (
        "/dev/cu.usbserial-*",
        "/dev/cu.usbmodem-*",
        "/dev/cu.SLAB_USBtoUART*",
        "/dev/cu.wchusbserial*",
    ):
        candidates.extend(glob.glob(pat))
    candidates = sorted(set(candidates))
    if not candidates:
        raise RuntimeError("UARTポートが見つかりません: /dev/cu.usbserial-* など")
    if len(candidates) == 1:
        return candidates[0]
    raise RuntimeError("UARTポート候補が複数あります。--port で指定してください: " + ", ".join(candidates))


def default_bin_path() -> str:
    preferred = [
        "build/Debug/nightfall_mini_v1_1.bin",
        "build/Debug/nightfall_classic_v2.bin",
    ]
    for p in preferred:
        if os.path.isfile(p):
            return p

    hits = []
    for pat in (
        "build/*/nightfall_mini_v1_1.bin",
        "build/*/nightfall_classic_v2.bin",
        "build/*/*.bin",
    ):
        hits.extend(glob.glob(pat))
    hits = [h for h in hits if os.path.isfile(h)]
    if not hits:
        raise RuntimeError(".bin が見つかりません。先にビルドしてください")
    return sorted(hits)[0]


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--port", default=None)
    ap.add_argument("--baud", type=int, default=115200)
    ap.add_argument("--bin", dest="bin_path", default=None)
    ap.add_argument("--no-erase", action="store_true")
    ap.add_argument("--erase-all", action="store_true", help="DANGEROUS: full chip erase (will delete saved params/maze)")
    ap.add_argument("--no-go", action="store_true")
    ap.add_argument("--base", default="0x08000000")
    ap.add_argument("--timeout", type=float, default=30.0)
    args = ap.parse_args()

    port = args.port or detect_port()
    bin_path = args.bin_path or default_bin_path()
    base = int(args.base, 0)

    with open(bin_path, "rb") as f:
        blob = f.read()

    print(f"PORT: {port}")
    print(f"BIN : {bin_path} ({len(blob)} bytes)")

    fd = open_uart_8e1(port, args.baud)
    try:
        did = connect_or_reuse(fd, args.timeout)
        if len(did) >= 2:
            chip_id = (did[-2] << 8) | did[-1]
            print(f"Device ID: 0x{chip_id:04X}")

        if not args.no_erase:
            if args.erase_all:
                extended_erase_all(fd)
            else:
                sectors = _f405_sectors_cover_range(base, len(blob))
                protected = _PROTECTED_SECTORS_DEFAULT
                if any(s in protected for s in sectors):
                    raise RuntimeError(
                        "Firmware image overlaps protected Flash sectors (params/maze). "
                        f"sectors_to_erase={sectors} protected={sorted(protected)}. "
                        "Reduce firmware size or change flash layout, or use --erase-all (not recommended)."
                    )
                extended_erase_sectors(fd, sectors)

        chunk = 256
        t0 = time.time()
        for off in range(0, len(blob), chunk):
            part = blob[off : off + chunk]
            write_memory(fd, base + off, part)
            written = off + len(part)
            render_bar("Write", written / len(blob), suffix=f" ({written}/{len(blob)} bytes)")
        sys.stdout.write("\n")
        print(f"write done in {time.time() - t0:.1f}s")

        if not args.no_go:
            go(fd, base)

        print("SUCCESS")
        return 0
    finally:
        os.close(fd)


if __name__ == "__main__":
    raise SystemExit(main())
