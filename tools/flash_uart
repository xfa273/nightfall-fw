#!/usr/bin/env python3

import argparse
import errno
import glob
import os
import signal
import struct
import subprocess
import sys
import time

import termios


ACK = 0x79
NACK = 0x1F

CMD_GETID = 0x02
CMD_GOMEM = 0x21
CMD_WRITEMEM = 0x31
CMD_EXT_ERASE = 0x44


def stm32f405_flash_sector_of_address(addr: int) -> int:
    if addr < 0x08000000:
        raise ValueError(f"address out of flash: 0x{addr:08X}")
    if addr < 0x08004000:
        return 0
    if addr < 0x08008000:
        return 1
    if addr < 0x0800C000:
        return 2
    if addr < 0x08010000:
        return 3
    if addr < 0x08020000:
        return 4
    if addr < 0x08040000:
        return 5
    if addr < 0x08060000:
        return 6
    if addr < 0x08080000:
        return 7
    if addr < 0x080A0000:
        return 8
    if addr < 0x080C0000:
        return 9
    if addr < 0x080E0000:
        return 10
    if addr < 0x08100000:
        return 11
    raise ValueError(f"address out of flash: 0x{addr:08X}")


def xor_checksum(bs: bytes) -> int:
    x = 0
    for b in bs:
        x ^= b
    return x & 0xFF


def _paired_tty_devices(port: str) -> list[str]:
    ports = [port]
    if port.startswith("/dev/cu."):
        ports.append(port.replace("/dev/cu.", "/dev/tty.", 1))
    elif port.startswith("/dev/tty."):
        ports.append(port.replace("/dev/tty.", "/dev/cu.", 1))
    return sorted(set(ports))


def _lsof_pids(path: str) -> list[int]:
    try:
        cp = subprocess.run(
            ["lsof", "-t", "--", path],
            check=False,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )
    except FileNotFoundError:
        raise RuntimeError("lsof が見つかりません。macOS標準ですが、存在しない場合は手動でポート使用中アプリを閉じてください")

    if cp.returncode == 0:
        out = []
        for line in cp.stdout.splitlines():
            line = line.strip()
            if not line:
                continue
            try:
                out.append(int(line))
            except ValueError:
                pass
        return sorted(set(out))

    if cp.returncode == 1 and not cp.stdout.strip():
        return []

    msg = cp.stderr.strip() or "unknown error"
    raise RuntimeError(f"lsof 実行に失敗しました: {msg}")


def _pid_command(pid: int) -> str:
    cp = subprocess.run(
        ["ps", "-p", str(pid), "-o", "command="],
        check=False,
        stdout=subprocess.PIPE,
        stderr=subprocess.DEVNULL,
        text=True,
    )
    return cp.stdout.strip() if cp.stdout else ""


def force_release_port(port: str, wait_s: float = 1.5) -> None:
    targets = [p for p in _paired_tty_devices(port) if os.path.exists(p)]
    pids: set[int] = set()
    for p in targets:
        for pid in _lsof_pids(p):
            if pid != os.getpid():
                pids.add(pid)

    if not pids:
        return

    print("Port is used by other processes. Terminating to release...")
    for pid in sorted(pids):
        cmd = _pid_command(pid)
        print(f"  pid={pid} cmd={cmd}")

    for pid in sorted(pids):
        try:
            os.kill(pid, signal.SIGTERM)
        except ProcessLookupError:
            pass
        except PermissionError:
            raise RuntimeError(f"プロセス(pid={pid})を終了できません（権限不足）。該当アプリを閉じるか sudo で実行してください")

    deadline = time.time() + max(0.1, wait_s)
    while time.time() < deadline:
        alive = False
        for pid in sorted(pids):
            try:
                os.kill(pid, 0)
                alive = True
            except ProcessLookupError:
                pass
            except PermissionError:
                alive = True
        if not alive:
            return
        time.sleep(0.05)

    for pid in sorted(pids):
        try:
            os.kill(pid, signal.SIGKILL)
        except ProcessLookupError:
            pass
        except PermissionError:
            raise RuntimeError(f"プロセス(pid={pid})を強制終了できません（権限不足）。該当アプリを閉じるか sudo で実行してください")


def open_uart_8e1(port: str, baud: int) -> int:
    try:
        fd = os.open(port, os.O_RDWR | os.O_NOCTTY | os.O_NONBLOCK)
    except OSError as e:
        if e.errno in (errno.EBUSY, errno.EACCES):
            raise RuntimeError(
                f"UARTポートを開けません: {port} ({e.strerror}). "
                "他のシリアルモニタ等が使用中の可能性があります。必要なら --force-release を指定してください"
            )
        raise

    attrs = termios.tcgetattr(fd)
    attrs[0] = 0
    attrs[1] = 0
    attrs[3] = 0

    cflag = attrs[2]
    cflag |= (termios.CLOCAL | termios.CREAD)
    cflag &= ~termios.CSIZE
    cflag |= termios.CS8
    cflag |= termios.PARENB
    cflag &= ~termios.PARODD
    cflag &= ~termios.CSTOPB
    attrs[2] = cflag

    if baud != 115200:
        raise ValueError("Only 115200 is supported in this script")

    attrs[4] = termios.B115200
    attrs[5] = termios.B115200

    attrs[6][termios.VMIN] = 0
    attrs[6][termios.VTIME] = 3

    termios.tcsetattr(fd, termios.TCSANOW, attrs)
    try:
        termios.tcflush(fd, termios.TCIOFLUSH)
    except Exception:
        pass

    return fd


def read_exact(fd: int, n: int, timeout_s: float) -> bytes:
    out = b""
    t0 = time.time()
    while len(out) < n and (time.time() - t0) < timeout_s:
        try:
            chunk = os.read(fd, n - len(out))
        except BlockingIOError:
            chunk = b""
        if chunk:
            out += chunk
        else:
            time.sleep(0.01)
    return out


def read_byte(fd: int, timeout_s: float):
    d = read_exact(fd, 1, timeout_s)
    return d[0] if d else None


def send(fd: int, data: bytes) -> None:
    os.write(fd, data)


def send_cmd(fd: int, cmd: int) -> None:
    send(fd, bytes([cmd, cmd ^ 0xFF]))


def expect_ack(fd: int, where: str, timeout_s: float) -> None:
    b = read_byte(fd, timeout_s)
    if b is None:
        raise RuntimeError(f"{where}: timeout")
    if b != ACK:
        raise RuntimeError(f"{where}: expected ACK(0x79) got 0x{b:02X}")


def render_bar(prefix: str, progress: float, suffix: str = "", width: int = 32) -> None:
    if progress < 0:
        progress = 0.0
    if progress > 1:
        progress = 1.0
    filled = int(round(width * progress))
    bar = "=" * filled + "-" * (width - filled)
    sys.stdout.write(f"\r{prefix} [{bar}] {progress*100:6.2f}%{suffix}")
    sys.stdout.flush()


def get_id(fd: int) -> bytes:
    send_cmd(fd, CMD_GETID)
    expect_ack(fd, "GETID ack1", 2.0)
    n = read_byte(fd, 2.0)
    if n is None:
        raise RuntimeError("GETID: no length")
    data = read_exact(fd, n + 1, 2.0)
    expect_ack(fd, "GETID ack2", 2.0)
    return data


def connect_or_reuse(fd: int, total_wait_s: float) -> bytes:
    deadline = time.time() + total_wait_s
    attempt = 0
    while time.time() < deadline:
        attempt += 1
        send(fd, b"\x7F")
        b = read_byte(fd, 0.6)
        if b == ACK:
            return get_id(fd)
        if b == NACK:
            try:
                did = get_id(fd)
                return did
            except Exception:
                pass
        time.sleep(0.2)

    raise RuntimeError("connect/reuse failed")


def extended_erase_all(fd: int) -> None:
    send_cmd(fd, CMD_EXT_ERASE)
    expect_ack(fd, "EXT_ERASE ack1", 2.0)
    payload = bytes([0xFF, 0xFF])
    send(fd, payload + bytes([xor_checksum(payload)]))
    print("Erasing...")
    expect_ack(fd, "EXT_ERASE ack2", 40.0)


def extended_erase_pages(fd: int, pages: list[int]) -> None:
    if not pages:
        return

    send_cmd(fd, CMD_EXT_ERASE)
    expect_ack(fd, "EXT_ERASE ack1", 2.0)

    pages = sorted(set(int(p) for p in pages))
    if any(p < 0 or p > 0xFFFD for p in pages):
        raise ValueError(f"invalid page numbers: {pages}")

    payload = struct.pack(">H", len(pages) - 1)
    for p in pages:
        payload += struct.pack(">H", p)

    send(fd, payload + bytes([xor_checksum(payload)]))
    print(f"Erasing pages: {pages}...")
    expect_ack(fd, "EXT_ERASE ack2", 40.0)


def compute_app_erase_pages(base: int, blob_len: int) -> list[int]:
    if blob_len <= 0:
        return []

    end = base + blob_len - 1
    first = stm32f405_flash_sector_of_address(base)
    last = stm32f405_flash_sector_of_address(end)

    pages = list(range(first, last + 1))
    protected = {10, 11}
    if any(p in protected for p in pages):
        raise RuntimeError(
            "書き込み範囲がSector10以降に到達します（Flash保存パラメータ領域を破壊する可能性）: "
            f"base=0x{base:08X} len={blob_len} end=0x{end:08X} pages={pages}"
        )
    return pages


def write_memory(fd: int, addr: int, data: bytes) -> None:
    if not (1 <= len(data) <= 256):
        raise ValueError("chunk size must be 1..256")

    send_cmd(fd, CMD_WRITEMEM)
    expect_ack(fd, "WRITEMEM ack1", 2.0)

    ab = struct.pack(">I", addr)
    send(fd, ab + bytes([xor_checksum(ab)]))
    expect_ack(fd, "WRITEMEM ack2", 2.0)

    ln = (len(data) - 1) & 0xFF
    payload = bytes([ln]) + data
    send(fd, payload + bytes([xor_checksum(payload)]))
    expect_ack(fd, "WRITEMEM ack3", 4.0)


def go(fd: int, addr: int) -> None:
    send_cmd(fd, CMD_GOMEM)
    expect_ack(fd, "GO ack1", 2.0)
    ab = struct.pack(">I", addr)
    send(fd, ab + bytes([xor_checksum(ab)]))
    expect_ack(fd, "GO ack2", 2.0)


def detect_port() -> str:
    candidates = []
    for pat in (
        "/dev/cu.usbserial-*",
        "/dev/cu.usbmodem-*",
        "/dev/cu.SLAB_USBtoUART*",
        "/dev/cu.wchusbserial*",
    ):
        candidates.extend(glob.glob(pat))
    candidates = sorted(set(candidates))
    if not candidates:
        raise RuntimeError("UARTポートが見つかりません: /dev/cu.usbserial-* など")
    if len(candidates) == 1:
        return candidates[0]
    raise RuntimeError("UARTポート候補が複数あります。--port で指定してください: " + ", ".join(candidates))


def default_bin_path() -> str:
    preferred = [
        "build/Debug/nightfall_mini_v1_1.bin",
        "build/Debug/nightfall_classic_v2.bin",
    ]
    for p in preferred:
        if os.path.isfile(p):
            return p

    hits = []
    for pat in (
        "build/*/nightfall_mini_v1_1.bin",
        "build/*/nightfall_classic_v2.bin",
        "build/*/*.bin",
    ):
        hits.extend(glob.glob(pat))
    hits = [h for h in hits if os.path.isfile(h)]
    if not hits:
        raise RuntimeError(".bin が見つかりません。先にビルドしてください")
    return sorted(hits)[0]


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--port", default=None)
    ap.add_argument("--baud", type=int, default=115200)
    ap.add_argument("--bin", dest="bin_path", default=None)
    ap.add_argument(
        "--force-release",
        action="store_true",
        help="ポート使用中のプロセスを検出して終了し、強制的にポートを解放します（macOS: lsof使用）",
    )
    ap.add_argument("--erase", choices=["app", "all", "none"], default="app")
    ap.add_argument("--no-erase", action="store_true")
    ap.add_argument("--erase-all", action="store_true")
    ap.add_argument("--no-go", action="store_true")
    ap.add_argument("--base", default="0x08000000")
    ap.add_argument("--timeout", type=float, default=30.0)
    args = ap.parse_args()

    port = args.port or detect_port()
    bin_path = args.bin_path or default_bin_path()
    base = int(args.base, 0)

    with open(bin_path, "rb") as f:
        blob = f.read()

    print(f"PORT: {port}")
    print(f"BIN : {bin_path} ({len(blob)} bytes)")

    if args.force_release:
        force_release_port(port)

    try:
        fd = open_uart_8e1(port, args.baud)
    except RuntimeError:
        if not args.force_release:
            raise
        force_release_port(port)
        fd = open_uart_8e1(port, args.baud)
    try:
        did = connect_or_reuse(fd, args.timeout)
        if len(did) >= 2:
            chip_id = (did[-2] << 8) | did[-1]
            print(f"Device ID: 0x{chip_id:04X}")

        if args.no_erase:
            args.erase = "none"
        if args.erase_all:
            args.erase = "all"

        if args.erase == "all":
            extended_erase_all(fd)
        elif args.erase == "app":
            pages = compute_app_erase_pages(base, len(blob))
            extended_erase_pages(fd, pages)

        chunk = 256
        t0 = time.time()
        for off in range(0, len(blob), chunk):
            part = blob[off : off + chunk]
            write_memory(fd, base + off, part)
            written = off + len(part)
            render_bar("Write", written / len(blob), suffix=f" ({written}/{len(blob)} bytes)")
        sys.stdout.write("\n")
        print(f"write done in {time.time() - t0:.1f}s")

        if not args.no_go:
            go(fd, base)

        print("SUCCESS")
        return 0
    finally:
        os.close(fd)


if __name__ == "__main__":
    raise SystemExit(main())
