#!/usr/bin/env python3

import argparse
import glob
import os
import struct
import sys
import time

import termios


ACK = 0x79
NACK = 0x1F

CMD_GETID = 0x02
CMD_GOMEM = 0x21
CMD_WRITEMEM = 0x31
CMD_EXT_ERASE = 0x44


_F405_SECTORS = [
    (0, 0x08000000, 16 * 1024),
    (1, 0x08004000, 16 * 1024),
    (2, 0x08008000, 16 * 1024),
    (3, 0x0800C000, 16 * 1024),
    (4, 0x08010000, 64 * 1024),
    (5, 0x08020000, 128 * 1024),
    (6, 0x08040000, 128 * 1024),
    (7, 0x08060000, 128 * 1024),
    (8, 0x08080000, 128 * 1024),
    (9, 0x080A0000, 128 * 1024),
    (10, 0x080C0000, 128 * 1024),
    (11, 0x080E0000, 128 * 1024),
]

_PROTECTED_SECTORS_DEFAULT = {9, 10, 11}


def xor_checksum(bs: bytes) -> int:
    x = 0
    for b in bs:
        x ^= b
    return x & 0xFF


def _f405_sector_for_addr(addr: int) -> int:
    for sid, start, size in _F405_SECTORS:
        if start <= addr < (start + size):
            return sid
    raise RuntimeError(f"address out of F405 flash range: 0x{addr:08X}")


def _f405_sectors_cover_range(start_addr: int, size_bytes: int) -> list[int]:
    if size_bytes <= 0:
        return []
    end_addr = start_addr + size_bytes - 1
    s0 = _f405_sector_for_addr(start_addr)
    s1 = _f405_sector_for_addr(end_addr)
    return list(range(s0, s1 + 1))


def extended_erase_sectors(fd: int, sectors: list[int]) -> None:
    if not sectors:
        return
    if len(sectors) > 0x10000:
        raise ValueError("too many sectors")

    send_cmd(fd, CMD_EXT_ERASE)
    expect_ack(fd, "EXT_ERASE ack1", 2.0)

    n = len(sectors) - 1
    payload = struct.pack(">H", n)
    for s in sectors:
        payload += struct.pack(">H", s & 0xFFFF)

    send(fd, payload + bytes([xor_checksum(payload)]))
    print(f"Erasing sectors: {sectors}")
    expect_ack(fd, "EXT_ERASE ack2", 40.0)

def write_memory(fd: int, addr: int, data: bytes) -> None:
    if not (1 <= len(data) <= 256):
        raise ValueError("chunk size must be 1..256")

    send_cmd(fd, CMD_WRITEMEM)
    expect_ack(fd, "WRITEMEM ack1", 2.0)

    ab = struct.pack(">I", addr)
    send(fd, ab + bytes([xor_checksum(ab)]))
    expect_ack(fd, "WRITEMEM ack2", 2.0)

    ln = (len(data) - 1) & 0xFF
    payload = bytes([ln]) + data
    send(fd, payload + bytes([xor_checksum(payload)]))
    expect_ack(fd, "WRITEMEM ack3", 4.0)


def go(fd: int, addr: int) -> None:
    send_cmd(fd, CMD_GOMEM)
    expect_ack(fd, "GO ack1", 2.0)
    ab = struct.pack(">I", addr)
    send(fd, ab + bytes([xor_checksum(ab)]))
    expect_ack(fd, "GO ack2", 2.0)


def detect_port() -> str:
    candidates = []
    for pat in (
        "/dev/cu.usbserial-*",
        "/dev/cu.usbmodem-*",
        "/dev/cu.SLAB_USBtoUART*",
        "/dev/cu.wchusbserial*",
    ):
        candidates.extend(glob.glob(pat))
    candidates = sorted(set(candidates))
    if not candidates:
        raise RuntimeError("UARTポートが見つかりません: /dev/cu.usbserial-* など")
    if len(candidates) == 1:
        return candidates[0]
    raise RuntimeError("UARTポート候補が複数あります。--port で指定してください: " + ", ".join(candidates))


def default_bin_path() -> str:
    preferred = [
        "build/Debug/nightfall_mini_v1_1.bin",
        "build/Debug/nightfall_classic_v2.bin",
    ]
    for p in preferred:
        if os.path.isfile(p):
            return p

    hits = []
    for pat in (
        "build/*/nightfall_mini_v1_1.bin",
        "build/*/nightfall_classic_v2.bin",
        "build/*/*.bin",
    ):
        hits.extend(glob.glob(pat))
    hits = [h for h in hits if os.path.isfile(h)]
    if not hits:
        raise RuntimeError(".bin が見つかりません。先にビルドしてください")
    return sorted(hits)[0]


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--port", default=None)
    ap.add_argument("--baud", type=int, default=115200)
    ap.add_argument("--bin", dest="bin_path", default=None)
    ap.add_argument("--erase", choices=["app", "all", "none"], default="app")
    ap.add_argument("--no-erase", action="store_true")
    ap.add_argument("--erase-all", action="store_true", help="DANGEROUS: full chip erase (will delete saved params/maze)")
    ap.add_argument("--no-go", action="store_true")
    ap.add_argument("--base", default="0x08000000")
    ap.add_argument("--timeout", type=float, default=30.0)
    args = ap.parse_args()

    port = args.port or detect_port()
    bin_path = args.bin_path or default_bin_path()
    base = int(args.base, 0)

    with open(bin_path, "rb") as f:
        blob = f.read()

    print(f"PORT: {port}")
    print(f"BIN : {bin_path} ({len(blob)} bytes)")

    fd = open_uart_8e1(port, args.baud)
    try:
        did = connect_or_reuse(fd, args.timeout)
        if len(did) >= 2:
            chip_id = (did[-2] << 8) | did[-1]
            print(f"Device ID: 0x{chip_id:04X}")

        if args.no_erase:
            args.erase = "none"
        if args.erase_all:
            args.erase = "all"

        if args.erase == "all":
            extended_erase_all(fd)
        elif args.erase == "app":
            sectors = _f405_sectors_cover_range(base, len(blob))
            protected = _PROTECTED_SECTORS_DEFAULT
            if any(s in protected for s in sectors):
                raise RuntimeError(
                    "Firmware image overlaps protected Flash sectors (params/maze). "
                    f"sectors_to_erase={sectors} protected={sorted(protected)}. "
                    "Reduce firmware size or change flash layout, or use --erase-all (not recommended)."
                )
            extended_erase_sectors(fd, sectors)

        chunk = 256
        t0 = time.time()
        for off in range(0, len(blob), chunk):
            part = blob[off : off + chunk]
            write_memory(fd, base + off, part)
            written = off + len(part)
            render_bar("Write", written / len(blob), suffix=f" ({written}/{len(blob)} bytes)")
        sys.stdout.write("\n")
        print(f"write done in {time.time() - t0:.1f}s")

        if not args.no_go:
            go(fd, base)

        print("SUCCESS")
        return 0
    finally:
        os.close(fd)


if __name__ == "__main__":
    raise SystemExit(main())
